(:~
 : _request.mod.xq - functions for loading and reading request data
 :
 : @version 20140214-1 first version 
 : ===================================================================================
 :)

module namespace m="http://www.ttools.org/xquery-functions";

import module namespace i="http://www.ttools.org/xquery-functions" at
   "_request_parser.mod.xq",
   "_request_getters.mod.xq",   
   "_dcat.mod.xq",
   "_extensions.mod.xq",
   "_help.mod.xq",   
   "_stringTools.mod.xq",   
   "_constants.mod.xq";   

declare namespace z="http://www.ttools.org/structure";

(:~
 : Parses a request string into a data structure.
 : 
 : @param request the request string
  : @return an element representing the request
 :)
declare function m:loadRequest($request as xs:string, $serviceModel as element()?)
        as element() {
(:        
    if (replace($request, '\s', '') eq '?') then <_help/> else
:)    
    let $parsed := i:_parseRequest($request)
    let $namesNormalized := m:_normalizeNames($parsed, $serviceModel)
    return
        if ($namesNormalized instance of element(z:error)) then 
            m:_getErrorReport($namesNormalized, ())  
        else
        
    let $opConfigPlus := m:_getOperationConfig($namesNormalized/local-name(.), $serviceModel)
    let $errors := $opConfigPlus/self::z:error    
    return
        if ($errors) then m:_getErrorReport($errors, ()) else
        
    let $valuesItemized := m:_itemizeParamValues($namesNormalized, $opConfigPlus, $serviceModel)
    let $valuesParsed := m:_parseParamValues($valuesItemized, $opConfigPlus, $serviceModel)
    let $groupErrors := m:_checkParamGroups($valuesParsed, $opConfigPlus, $serviceModel)
    let $errors := ($valuesParsed//z:error, $groupErrors)    
    return
        if ($errors) then m:_getErrorReport($errors, ()) else  
            $valuesParsed
};

(:~
 : Transforms the result of parsing the request string into name/value pairs, 
 : replacing the operation name and the parameter names by normalized names.
 : 
 : May produce the following errors:
 :    UNKNOWN_OPERATION_NAME
 :    AMBIGUOUS_OPERATION_NAME
 :    UNKNOWN_PARAMEER_NAME
 :    AMBIGUOUS_PARAMETER_NAME
 :
 : @param parsed an element representing the name/value pairs obtained by parsing the 
 :    request string
 : @param serviceModel a definition of all service operations
 : @return an element representing the parsed and name-normalized request string
 :)
declare function m:_normalizeNames($parsed as element(), $serviceModel as element()?)
        as element() {
    if (not($serviceModel)) then $parsed else
    
    (: operation name :)
    let $rawName := $parsed/@operation
    let $candidateNames := for $n in $serviceModel/operation/@name order by lower-case($n) return $n
    let $matchingNames := m:_matchingNames($rawName, $candidateNames)
    let $opName := 
        if (count($matchingNames) eq 1) then $matchingNames 
        else if (count($matchingNames) eq 0) then
            <z:error type="UNKNOWN_OPERATION_NAME" name="{$rawName}"
                validNames="{$candidateNames}"
                msg="{concat('Unknown operation name (', $rawName, 
                '); valid names: ', string-join($candidateNames, ' '))}"/>
        else
            <z:error type="AMBIGUOUS_OPERATION_NAME" name="{$rawName}"
                matchingNames="{string-join($matchingNames, ', ')}"
                msg="{concat('Ambiguous operation name (', $rawName,
                '); matching names: ', string-join($matchingNames, ', '))}"/>
    return
        if ($opName instance of element(z:error)) then $opName else
    
    (: parameter names :)
    let $opConfig := $serviceModel/operation[@name eq $opName]                
    let $params :=
        for $param in $parsed/param
        let $rawName := $param/@name
        let $candidateNames := for $n in $opConfig/param/@name order by lower-case($n) return $n
        let $matchingNames := m:_matchingNames($rawName, $candidateNames)
        let $paramName :=
            if (count($matchingNames) eq 1) then $matchingNames 
            else if (count($matchingNames) eq 0) then
                <z:error type="UNKNOWN_PARAMETER_NAME" name="{$rawName}"
                    validNames="{$candidateNames}" msg="{concat('Unknown parameter name (', $rawName, '); ',
                    'valid names: ', string-join($candidateNames, ' '))}"/>
            else
                <z:error type="AMBIGUOUS_PARAMETER_NAME" name="{$rawName}"
                    matchingNames="{string-join($matchingNames, ', ')}"
                    msg="{concat('Ambiguous parameter name (', $rawName, 
                    '); matching names: ', string-join($matchingNames, ', '))}"/>            
        return
            if ($paramName instance of element(z:error)) then $paramName else
            <param name="{$paramName}" value="{$param/@value}"/>
    return
        element {$opName} {$parsed/@storeq, $params}
};

(:~
 : Transforms the intermediate representation of the request string, replacing the
 : concatenated parameter values by itemized values.
 : 
 : @param parsed an element representing the parsed request string
 : @return intermediate representation of the request in which external parameter 
 :    values are itemized
 :)
declare function m:_itemizeParamValues($normalizedNames as element(), 
                                       $opConfigPlus as element(), 
                                       $serviceModel as element()?)
        as element() {
    if (not($serviceModel)) then $normalizedNames else
    
    let $setParamNames := $normalizedNames/param/@name
    let $defaultParameters := $opConfigPlus/param[@default][not(@name = $setParamNames)]
    let $defaultsAdded := 
        if (not($defaultParameters)) then $normalizedNames else
            element {node-name($normalizedNames)} {
                $normalizedNames/@*,
                $normalizedNames/*,
                for $dparam in $defaultParameters return
                    <param name="{$dparam/@name}" value="{$dparam/@default}"/>
            }
    let $params :=
        for $param in $defaultsAdded/param
        let $paramConfig := $opConfigPlus/param[@name eq $param/@name]
        let $maxOccurs as xs:integer := $paramConfig/@maxOccurs/xs:integer(.)
        let $multiple as xs:boolean := $maxOccurs lt 0 or $maxOccurs gt 1
        let $rawItem := $param/@value/string(.)
        let $sep := 
            if (not($multiple)) then ()
            (: there are types for which the item separator is defined to be a semicolon :)
            else if ($paramConfig/@itemType = ('docDFD')) then '\s*;\s*'
            else ($paramConfig/@sep, '\s')[1]
        let $sep := replace($sep, '\\s\+', '\\s')
        let $sep := replace($sep, '^WS$', '\\s')
        let $items :=
            if (not($multiple)) then 
                $param/@value/replace(., '\\\\', '\\')
            else if ($sep eq '\s') then 
                tokenize(normalize-space($param/@value/replace(., '\\\\', '\\')), '\s+')
            else 
                m:_itemizeValue($param/@value, $sep)
        let $sepAtt := 
            if ($multiple and count($items) gt 1 and $sep eq '\s') then attribute sep {'\s'}
            else ()
        return
            element {node-name($param)} {
                $param/@name,
                attribute paramText {$rawItem},
                $paramConfig/@itemType,
                $paramConfig/@cardinality[string(.)],
                $sepAtt,
                if (count($items) eq 1) then 
                    $rawItem
                else if ($sep eq '\s') then 
                    string-join($items, ' ')
                else
                    for $item in $items return <value>{$item}</value>
            }
    return
        element {node-name($defaultsAdded)} {        
            $defaultsAdded/@*,
            $defaultsAdded/z:error,
            $params
        }
};

(:~
 : Parses and validates the parameter values and writes the final XML representation 
 : of the request.
 :
 : Error policy: any cardinality errors are detected and captured by "error"
 : elements; in case of such errors, the processing is not aborted in order
 : to provide an error report which is as complete as possible.
 : 
 : @param valuesDetermined an intermediate representation of the request containing the not yet parsed
 :    and not yet validated parameter values
 : @opConfig the operation config
 : @serviceModel the service config
 : @return an element representing the request in which each parameter is represented by the 
 :    result of parsing and validating the original value
 :)
declare function m:_parseParamValues($valuesItemized as element(), 
                                     $opConfigPlus as element(), 
                                     $serviceModel as element()?)
        as element()* {
    if (not($serviceModel)) then $valuesItemized else

    (: check for missing parameters :)
    let $missingParamErrors :=
        for $p in $opConfigPlus/param[@minOccurs/xs:integer(.) gt 0]
                                     [not(@name = $valuesItemized/param/@name)]                                    
        return
            <z:error type="MISSING_PARAMETER" paramName="{$p/@name}"
                msg="{concat('Missing parameter: ', $p/@name, 
                    '; cardinality=', $p/@minOccurs, '-', $p/@maxOccurs/replace(., '-1', 'INF'))}"/>
    (: check for cardinality errors, parse and validate the parameter values :)                    
    let $paramsAndErrors :=   
        for $param in $valuesItemized/param
        let $name := $param/@name/string(.)
        let $paramText := $param/@paramText
        let $valueItems := m:_getUnparsedParamItems($param)        
        let $paramConfigPlus := $opConfigPlus/param[@name eq $name]

        let $minOccurs := $paramConfigPlus/@minOccurs/xs:integer(.)[. ge 0]
        let $maxOccurs := $paramConfigPlus/@maxOccurs/xs:integer(.)[. ge 0]        
        let $type := $paramConfigPlus/@type
        let $itemType := $paramConfigPlus/@itemType
        let $cardinalityError := 
            if (count($valueItems) lt $minOccurs or count($valueItems) gt $maxOccurs) then
                let $sep := ($paramConfigPlus/@sep, '\s')[1] return
                <z:error type="INVALID_PARAMETER_CARDINALITY" paramName="{$name}" paramType="{$type}" 
                    itemCount="{count($valueItems)}" itemSeperator="{$sep}"
                    msg="{concat('Invalid parameter cardinality; actOccurs=', count($valueItems), '; minOccurs=', $minOccurs,
                     '; maxOccurs=', $maxOccurs)}"/>
            else ()                

        return (
            $cardinalityError,
            m:_parseParamValue($name, $paramText, $valueItems, $itemType, $paramConfigPlus)
        )            
    return
        element {node-name($valuesItemized)} {
            $valuesItemized/@storeq,        
            $valuesItemized/z:error,
            $missingParamErrors,
            $paramsAndErrors
        }
};

(:~
 : Parses a parameter value into a structure representation. The
 : representation is an element whose name if the parameter name and
 : whose text content or item children represent the parsed value items.
 :
 : @param name name the parameter name
 : @param value the parameter value
 : @param itemType the parameter type
 : @param paramConfig the parameter configuration
 : @return a "param" element capturing the information content
 :    of the parameter value
 :)
declare function m:_parseParamValue($name as xs:string, 
                                    $paramText as xs:string,
                                    $value as xs:string+, 
                                    $itemType as xs:string, 
                                    $paramConfig as element()?)
        as element()* {
        
    let $edits := $paramConfig/@edit/(for $item in tokenize(normalize-space(.), '\s') return $item)
    let $postEdits := $paramConfig/@postEdit/(for $item in tokenize(normalize-space(.), '\s') return $item)        
    let $typedValue :=             
        for $item in $value 
        let $itemText := m:_prepareParamValueItemText($item, $edits)
        let $typedItem := m:_parseParamValueItem($item, $itemType, $name)
        let $validationErrors :=            
            if (not($paramConfig) or 
                $typedItem instance of element(z:error) or 
                $typedItem instance of element(z:errors)) then () 
            else if ($itemType = ('DocDFD')) then ()
            else m:_validateFacets($itemText, $typedItem, $paramConfig)
        return
            if ($validationErrors) then $validationErrors else $typedItem
            
    let $paramErrors := $typedValue[. instance of element(z:error) or . instance of element(z:errors)]                    
    let $paramValue := $typedValue[not(. instance of element(z:error) or . instance of element(z:errors))]
    let $isValueNodes as xs:boolean := some $v in $paramValue satisfies $v instance of node()
    let $isValueSingleton as xs:boolean := count($paramValue) le 1
    
    let $concatenate as xs:boolean :=
        not($paramErrors) and 
            not($isValueNodes) and 
            not($isValueSingleton) and 
            not(exists($value[matches(string(.), '\s')]))
    let $paramValueNodes as node()* :=
        if ($paramErrors) then $paramErrors 
        else if ($isValueNodes) then
            if ($isValueSingleton) then $paramValue else 
                $paramValue/<value>{.}</value>
        else
            if (empty($paramValue)) then ()
            else if ($isValueSingleton) then text {$paramValue}           
            else if ($concatenate) then 
                text {string-join(for $i in $paramValue return string($i), ' ')}
            else                    
                for $item in $paramValue return <value>{$item}</value>

    let $paramElem :=
        element {$name} {
            (: attribute type {$type}, :)
            attribute itemType {$itemType},
            attribute paramText {$paramText},
            if (not($isValueNodes)) then () else attribute nodeItems {'true'},
            if ($concatenate and not($isValueSingleton)) then attribute sep {'\s'} else (),
            $paramValueNodes
        }
    return
        $paramElem
};

(:~
 : Prepares the text of a single parameter item for parsing.
 :
 : @param item the parameter item text
 : @return the parameter item as a typed item
 :)
declare function m:_prepareParamValueItemText($item as xs:string, $edits as xs:string*)
        as xs:string {
    let $itemChopped := replace(replace($item, '^\s+|\s+$', ''), '\\s', ' ')
    let $itemText :=
        if (empty($edits)) then $itemChopped else m:_editItem($itemChopped, $edits)
    return
        $itemText
};

(:~
 : Parses the text of a single parameter item.
 :
 : @param item the parameter item text
 : @return the parameter item as a typed item
 :)
declare function m:_parseParamValueItem($itemText as xs:string, $itemType as xs:string, $name as xs:string)
        as item()? {
    let $typedItem := 
        if ($itemType eq 'xs:string') then $itemText
        else if ($itemType eq 'xs:NCName') then
            if ($itemText castable as xs:NCName) then xs:NCName($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value ''',
                    $itemText, ''' not a valid NCName value.')}"/>                       
        else if ($itemType eq 'xs:boolean') then
            if ($itemText castable as xs:boolean) then xs:boolean($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value ''',
                    $itemText, ''' not a boolean value.')}"/>                       
        else if ($itemType eq 'xs:integer') then
            if ($itemText castable as xs:integer) then xs:integer($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not an integer number.')}"/>                       
        else if ($itemType eq 'xs:positiveInteger') then
             if ($itemText castable as xs:positiveInteger) then xs:positiveInteger($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not a positive integer number.')}"/>                       
        else if ($itemType eq 'xs:nonNegativeInteger') then
            if ($itemText castable as xs:nonNegativeInteger) then xs:nonNegativeInteger($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not a non-negative integer number.')}"/>                       
        else if ($itemType eq 'xs:negativeInteger') then
            if ($itemText castable as xs:negativeInteger) then xs:negativeInteger($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not a negative integer number.')}"/>                       
        else if ($itemType eq 'xs:nonPositiveInteger') then
            if ($itemText castable as xs:nonPositiveInteger) then xs:nonPositiveInteger($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not a non-positive integer number.')}"/>                       
        else if ($itemType eq 'xs:int') then
            if ($itemText castable as xs:int) then xs:int($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not an xs:int number.')}"/>                       
        else if ($itemType eq 'xs:decimal') then
            if ($itemText castable as xs:decimal) then xs:decimal($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not an xs:decimal number.')}"/>                       
        else if ($itemType eq 'xs:date') then
            if ($itemText castable as xs:date) then xs:date($itemText) else
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                    $itemText, ') not a valid date.')}"/>                       
        else if ($itemType eq 'nameFilter') then            
            let $nameFilter := i:parseNameFilter($itemText) return
            if ($nameFilter and not($nameFilter/self::z:errors)) then $nameFilter else
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': not a valid nameFilter.')}"/>                       
        else if (matches($itemType, '^nameFilterMap(\(.*\))?$')) then            
            let $nameFilterMap := i:parseNameFilterMap($itemText, $itemType) return
            if ($nameFilterMap and not($nameFilterMap/self::z:errors)) then $nameFilterMap else
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': not a valid nameFilter map.')}"/>                       
        else if ($itemType eq 'pathFilter') then            
            let $pathFilter := i:parsePathFilter($itemText) return
            if ($pathFilter and not($pathFilter/self::z:errors)) then $pathFilter else
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': not a valid pathFilter.')}"/>                       
        else if ($itemType eq 'docURI') then            
            if (doc-available($itemText)) then $itemText else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no XML document at this location (',
                     $itemText, ').')}"/>                       
        else if ($itemType eq 'docDFD') then
            let $dcat := i:parseDocDFD($itemText) return            
            if ($dcat and not($dcat/self::z:errors)) then $dcat else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>                       
        else if ($itemType eq 'docCAT') then
            if (doc-available($itemText)) then 
                let $root := doc($itemText)/*
                return
                    if (local-name($root) eq 'dcat' and namespace-uri($root) eq '') then $itemText else
                        <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                             itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': document at this location (', 
                             $itemText, ') is not a dcat document.')}"/>                    
            else              
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no dcat document at this location (', 
                     $itemText, ').')}"/>                      
        else if ($itemType eq 'dcat') then
            let $dcat := i:parseDocDFD($itemText) return            
            if ($dcat and not($dcat/self::z:errors)) then $dcat else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>                       
        else if ($itemType eq 'textURI') then
            let $itext := replace($itemText, '\\', '/')
            let $fields := i:_getItemFields($itext)
            let $encoding := ($fields[2], 'ISO-8859-1')[1]
            let $uri := $fields[1]
            return        
                if (unparsed-text-available($uri, $encoding)) then $itext else               
                    <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no text resource at this location (',
                     $uri, ').')}"/>                       
        else if ($itemType eq 'textDFD') then
            let $dcat := i:parseTextDFD($itemText) return            
            if ($dcat and not($dcat/self::z:errors)) then $dcat else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>                       
        else if ($itemType eq 'textLinesDFD') then
            let $dcat := i:parseTextDFD($itemText) return            
            if ($dcat and not($dcat/self::z:errors)) then $dcat else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>                       
        else if ($itemType eq 'textLinesURI') then   
            let $itext := replace($itemText, '\\', '/')
            let $fields := m:_getItemFields($itext)
            let $encoding := ($fields[2], 'ISO-8859-1')[1]
            let $uri := $fields[1]
            return
                if (unparsed-text-available($uri, $encoding)) then $itext else               
                    <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                         itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no text resource at this location (',
                         $uri, ').')}"/>
        else if ($itemType eq 'csvURI') then
            let $itext := replace($itemText, '\\', '/')
            let $fields := i:_getItemFields($itext)
            let $encoding := ($fields[2], 'ISO-8859-1')[1]
            let $sep := ($fields[3], ';')[1] 
            let $delim := ($fields[4], '"')[1]            
            let $uri := $fields[1]
            return        
                if (unparsed-text-available($uri, $encoding)) then $itext else               
                    <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no text resource at this location (',
                     $uri, ').')}"/>                       
                         
        else if ($itemType eq 'csvDFD') then
            let $dcat := i:parseCsvDFD($itemText) return
            
            if ($dcat and not($dcat/self::z:errors)) then $dcat
(:            
                    let $fields := i:_getItemFields($itemText)
                    return
                        (: augment dcat - transfer field values into attributes (e.g. @sep) :)
                        element {node-name($dcat)} {
                            $dcat/@*,
                            attribute sep {($fields[6], ';')[1]},
                            attribute delim {($fields[7], '"')[1]},                            
                            attribute from {($fields[8], '1')[1]},                            
                            attribute to {($fields[9], '1')[-1]},
                            $dcat/node()                            
                        }
:)                        
            else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>                       
                         
        else if ($itemType eq 'directory') then  
            let $itext := replace($itemText, '\\', '/')
            let $value := resolve-uri($itext, static-base-uri())
            let $value := file:resolve-path($value)
            return $value
        else i:parseNonStandardItemType($name, $itemType, $itemText)
    return
        $typedItem
};

declare function m:_validateFacets($itemText as xs:string, $typedItem as item(), $paramConfig as element()?)
        as element()* {
        
    let $itemType := $paramConfig/@itemType
    let $name := $paramConfig/@name
        
    let $errors :=            
        if (not($paramConfig) or 
            $typedItem instance of element(z:error) or 
            $typedItem instance of element(z:errors)) then () 
        else if ($itemType = ('DocDFD')) then ()
        else (
            
            (: *** check @values :)
            if (not($paramConfig/@fct_values)) then () else
            let $expectedItems := tokenize($paramConfig/@fct_values, ', ')
            return
                if ($itemText = $expectedItems) then () else               
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="values" validItemValues="{$paramConfig/@fct_values}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $typedItem, ') not among the valid ',
                        'item values (', $paramConfig/@fct_values, ').')}"/>
            ,
            (: *** check @pattern :)
            if (not($paramConfig/@fct_pattern)) then () else
            let $patternSpec := $paramConfig/@fct_pattern
            let $pattern := concat('^', replace($patternSpec, '#.*', ''), '$')
            let $options := string(replace($patternSpec, '.*#', '')[not(. eq $patternSpec)])
            return
                if (matches($itemText, $pattern, $options)) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="pattern" pattern="{$patternSpec}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $itemText, ') does not match the ',
                        'pattern (', $patternSpec, ').')}"/>
            ,
            (: *** check @length :)
            if (not($paramConfig/@fct_length)) then () else
            let $length := $paramConfig/@fct_length/xs:integer(.)
            return
                if (string-length($itemText) eq $length) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="length" length="{$length}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $itemText, ') does not have the required ',
                        'string length (', $length, ').')}"/>
            ,
            (: *** check @minLength :)
            if (not($paramConfig/@fct_minLength)) then () else
            let $minLength := $paramConfig/@fct_minLength/xs:integer(.)
            return
                if (string-length($itemText) ge $minLength) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="minLength" minLength="{$minLength}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $itemText, ') does not have the required ',
                        'minimum string length (', $minLength, ').')}"/>
            ,
            (: *** check @maxLength :)
            if (not($paramConfig/@fct_maxLength)) then () else
            let $maxLength := $paramConfig/@fct_maxLength/xs:integer(.)
            return
                if (string-length($itemText) le $maxLength) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="maxLength" maxLength="{$maxLength}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $itemText, ') has a length (', 
                        string-length($itemText), ') exceeding the maximum valid string length (', $maxLength, ').')}"/>
            ,
            (: *** check @min :)
            if (not($paramConfig/@fct_min)) then () else
            let $min := 
                if ($itemType eq 'xs:date') then $paramConfig/@fct_min/xs:date(.)
                else if ($itemType eq 'xs:time') then $paramConfig/@fct_min/xs:time(.)                
                else if ($itemType eq 'xs:dateTime') then $paramConfig/@fct_min/xs:dateTime(.)
                else $paramConfig/@fct_min/number(.)               
            return
                if ($typedItem ge $min) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="min" min="{$min}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $typedItem, ') does not have the required ',
                        'minimum value (', $min, ').')}"/>
            ,
            (: *** check @max :)
            if (not($paramConfig/@fct_max)) then () else
            let $max :=
                if ($itemType eq 'xs:date') then $paramConfig/@fct_max/xs:date(.)
                else if ($itemType eq 'xs:time') then $paramConfig/@fct_max/xs:time(.)                
                else if ($itemType eq 'xs:dateTime') then $paramConfig/@fct_max/xs:dateTime(.)
                else $paramConfig/@fct_max/number(.)               
            return
                if ($typedItem le $max) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="max" max="{$max}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $typedItem, ') larger than the maximum valid ',
                        'value (', $max, ').')}"/>            
            ,
            
            (: *** check @fileExists :)
            if (not($paramConfig/@fct_fileExists)) then () 
            else if ($paramConfig/@fct_fileExists eq 'true' and not(file:exists($typedItem))) then              
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$typedItem}" facet="fileExists" facetValue="true" 
                     msg="{concat('Parameter ''', $name, ''': file ''', $typedItem, ''' not found.')}"/>
            else if ($paramConfig/@fileExists eq 'false' and file:exists($typedItem)) then              
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$typedItem}" facet="fileExists" facetValue="false" 
                     msg="{concat('Parameter ''', $name, ''': file ', $typedItem, ''' already exists.')}"/>
            else (),           

            (: *** check @fct_dirExists :)
            if (not($paramConfig/@fct_dirExists)) then () 
            else if ($paramConfig/@fct_dirExists eq 'true' and not(file:exists($typedItem))) then              
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$typedItem}" facet="dirExists" facetValue="true" 
                     msg="{concat('Parameter ''', $name, ''': directory ''', $typedItem, ''' not an existent directory.')}"/>
            else if ($paramConfig/@fct_dirExists eq 'false' and file:exists($typedItem)) then              
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$typedItem}" facet="dirExists" facetValue="false" 
                     msg="{concat('Parameter ''', $name, ''': directory ', $typedItem, ''' already exists.')}"/>
            else ()         
            )
    return
        $errors            
};

(:~
 : Checks any constraints referring to parameter groups.
 :
 : Checks: minimum and maximum number of group members
 : 
 : @param parsed an element representing the parsed request string
 : @return intermediate representation of the request in which external parameter 
 :    values are itemized
 :)
declare function m:_checkParamGroups($request as element(), 
                                     $opConfigPlus as element(), 
                                     $serviceModel as element()?)
        as element()* {
    for $g in $opConfigPlus/pgroup
    let $gname := $g/@name
    let $memberNames := $g/@members/tokenize(., '\s+')
    let $actMemberNames := $request/*[local-name() = $memberNames]
    let $actMembers := count($actMemberNames)
    let $minMembers := $g/@minMembers/xs:integer(.)    
    let $maxMembers := $g/@maxMembers/xs:integer(.)    
    return (
        (: exactly one param must be set :)
        if ($minMembers eq $maxMembers) then
            if ($actMembers eq $minMembers) then () else
                <z:error type="INVALID_PARAMETER_GROUP" subType="MIN_MEMBERS" paramGroupName="{$gname}" 
                    minMembers="{$minMembers}" maxMembers="{$maxMembers}" actMembers="{$actMembers}">{                       
                        attribute msg 
                            {concat('Exactly ', $minMembers, ' of these parameters must be set: ',
                             string-join($memberNames, ', '), '.')}
                }</z:error>            
        else       
            if (not($g/@minMembers)) then () else
                if ($actMembers eq $minMembers) then () else
                    <z:error type="INVALID_PARAMETER_GROUP" subType="MIN_MEMBERS" paramGroupName="{$gname}" 
                        minMembers="{$minMembers}" actMembers="{$actMembers}">{                       
                            attribute msg 
                                {concat('At least ', $minMembers, ' of these parameters must be set: ',
                                 string-join($memberNames, ', '), '.')}
                    }</z:error>,
            if (not($g/@maxMembers)) then () else
                if ($actMembers eq $maxMembers) then () else
                        <z:error type="INVALID_PARAMETER_GROUP" subType="MIN_MEMBERS" paramGroupName="{$gname}" 
                            maxMembers="{$maxMembers}" actMembers="{$actMembers}">{                       
                                attribute msg 
                                    {concat('At most ', $maxMembers, ' of these parameters must be set: ', 
                                     string-join($memberNames, ', '), '.')}
                        }</z:error>
    )                    
};

(:~
 : Returns for a given name the normalized name(s) which the given name matches. 
 : The matches are determined as follows: (a) if there are candidate names which
 : are equal to the given name, ignoring case - the first or these candidate names;
 : (b) otherwise - all candidate names which start with the given name, ignoring case.
 : 
 : @param rawName the name as specified in the original request data
 : @return the matching name(s)
 :)
declare function m:_matchingNames($rawName as xs:string, $candidateNames as xs:string*)
        as xs:string* {
    if (empty($candidateNames)) then () else
    
    let $exactMatch := $candidateNames[matches($rawName, concat('^', ., '$'), 'i')][1]
    return
        if (exists($exactMatch)) then $exactMatch
        else
            let $rawPattern := concat('^', $rawName)
            let $matches := $candidateNames[matches(., $rawPattern, 'i')]
            return
                $matches
};

(:~
 : Returns an augmented operation config. The operation is identified by the operation name. 
 : In the returned operation config ...
 : - each parameter group element is augmented by a @members attribute containing the sorted
 :   list of member parameter names
 : - each parameter element is augmented by four additional attributes:
 :    @itemType - the result of removing the cardinality postfix from the type specification
 :    @cardinality - the cardinality postfix of the type specification
 :    @minOccurs - minimum number of occurrences
 :    @maxOccurs - maximum number of occurrences
 :
 : @param operationName the operation name
 : @param serviceModel a definition of all service operations 
  : @return an element describing the operation
 :)
declare function m:_getOperationConfig($operationName as xs:string, $serviceModel as element())
        as element()? {
    let $patternCardinality := '\s*(\?|\*|\+|\{).*$'
    let $raw := $serviceModel/*[@name eq $operationName]
    
    (: $pgroups - elements representing the parameter groups :)
    let $pgroups :=
        for $g in $raw/pgroup
        let $gname := $g/@name
        let $members := $raw/param[@pgroup eq $gname]
        let $memberNames :=
            string-join(
                for $member in $members order by $member/@name/lower-case(.) return $member/@name
            , ' ')
        return
            element {node-name($g)} {$g/@*, attribute members {$memberNames}}
    
    (:~ $params - elements representing the parameters :)
    let $params :=
        for $p in $raw/param
        let $type := $p/@type
        let $itemType := replace($type, $patternCardinality, '', 's')
        let $cardSpec :=
            normalize-space(
                replace(
                    replace($type, concat('.*(', $patternCardinality, ')'), '$1', 's')[. ne $type], 
                        '\s', ''))
        let $minMax := m:_getMinMaxOccurs($cardSpec, $type)
(:        
            if (not($cardSpec)) then (1, 1)
            else if ($cardSpec eq '?') then (0, 1)
            else if ($cardSpec eq '*') then (0, -1)            
            else if ($cardSpec eq '+') then (1, -1)
            else
                let $range := replace($cardSpec, '^\{(.*)\}$', '$1', 's')
                let $minCommaMax := 
                    if (not(contains($range, ','))) then $range else
                        replace($range, '^(\d*)(,)(\d*)$', '$1:$2:$3')[. ne $range]                
                let $comps := tokenize($minCommaMax, ':')[.]
                return
                    if (count($comps) eq 0 
                        or count($comps) eq 1 and $comps eq ','
                        or count($comps) eq 2 and not($comps = ',')) 
                        then (: syntax error :)
                            <z:error type="INVALID_CARDINALITY_CONSTRAINT" typeSpec="{$type}"/>
                    else if (count($comps) eq 1) then ($comps, $comps)                        
                    else if (count($comps) eq 3) then ($comps[1], $comps[3])                    
                    else if ($comps[2] eq ',') then ($comps[1], -1)
                    else if ($comps[1] eq ',') then (-1, $comps[2])       
                    else ()
:)                    
        return
            if ($minMax instance of node()) then $minMax else
            
            <param>{
                $p/@*,
                attribute itemType {$itemType},
                attribute cardinality {$cardSpec},
                attribute minOccurs {$minMax[1]},
                attribute maxOccurs {$minMax[2]}                
            }</param>
    return
        element {node-name($raw)} {$raw/@*, $params, $pgroups}
};    

(:~
 : Returns for a given cardinality constraint the values for minOccurs
 : and maxOccurs. An unbounded value is represented by -1. In case of
 : an error, an error element is returned, rather than two integer numbers.
 :
 : Possible errors:
 : INVALID_CARDINALITY_CONSTRAINT - if the constraint is syntactically incorrect
 :
 : @param cardSpec a cardinality constraint (e.g. ?, *, +, {12}m {0,7}
 : @return a sequence of two integers representing the minOccurs and
 :    maxOccurs values implied by the cardinality constraint
 :)
declare function m:_getMinMaxOccurs($cardSpec as xs:string?, $typeSpec as xs:string)
        as item()* {
    if (not($cardSpec)) then (1, 1)
    else if ($cardSpec eq '?') then (0, 1)
    else if ($cardSpec eq '*') then (0, -1)            
    else if ($cardSpec eq '+') then (1, -1)
    else
        let $range := replace($cardSpec, '^\{(.*)\}$', '$1', 's')
        let $minCommaMax := 
            if (not(contains($range, ','))) then $range else
                replace($range, '^(\d*)(,)(\d*)$', '$1:$2:$3')[. ne $range]                
        let $comps := tokenize($minCommaMax, ':')[.]
        return
            if (count($comps) eq 0 
                or count($comps) eq 1 and $comps eq ','
                or count($comps) eq 2 and not($comps = ',')) 
                then (: syntax error :)
                    <z:error type="INVALID_CARDINALITY_CONSTRAINT" typeSpec="{$typeSpec}"
                        msg="{concat('Invalid cardinality constraint; type=', $typeSpec)}"/>
            else if (count($comps) eq 1) then ($comps, $comps)                        
            else if (count($comps) eq 3) then ($comps[1], $comps[3])                    
            else if ($comps[2] eq ',') then ($comps[1], -1)
            else if ($comps[1] eq ',') then (-1, $comps[2])       
            else <z:error type="SYSTEM_ERROR" details="This case should never occur"
                    msg="System error - this case should never be reached"/>
};

(:~
 : Parses a parameter value string into a sequence of items.
 : 
 : @param request the request string
 : @return an element representing the request
 :)
declare function m:_itemizeValue($value as xs:string, $sepChar as xs:string)
      as xs:string* {
    m:_parseValueRC($value, $sepChar)
};

(:~
 : Recursive helper function of _parseValue. Extracts the next
 : value item and recursively calls itself for processing the
 : remainder of the value string, if there is a remainder.
 :
 : @param value the value string
 : @return the value items
 :) 
declare function m:_parseValueRC($value as xs:string?, $sepChar as xs:string)
        as xs:string* {
    if (empty($value)) then () else
    let $item := 
        replace($value, concat('^(.*?[^\\](\\\\)*)?', $sepChar, '($|[^', $sepChar, '].*)'), '$1', 's')    
    let $next := if ($item eq $value) then () else
        replace(substring($value, string-length($item) + 2), '^\s+', '')
    return (
        replace(replace($item, '\\\\', '\\'), concat('\\', $sepChar), m:_escapeReplacementString($sepChar)),
        if (empty($next)) then () else m:_parseValueRC($next, $sepChar)
    )            
};        

(:~
 : Writes an error report. Note that the 'error' elements may be in the
 : general topicTools namespace, as well as in a tool specific namespace.
 : Therefore, the element test does not specify an element name.
 :)
declare function m:_getErrorReport($errors as element()*, $format as xs:string?)
        as element(z:errorReport) {
    let $msgs := $errors/concat(m:_padRight(@type, 30), m:_foldText(@msg, 100, 30, 33))
    return
    <z:errorReport>{
        string-join((
            '', 
            'Invalid call',
            '============',
            '',
            $msgs, 
            '',
            '-------------------------------------',
            ''
        ), '&#xA;')  
    }</z:errorReport>
};        

declare function m:_padRight($s as xs:string?, $width as xs:integer)
        as xs:string? {
    substring(concat($s, string-join(for $i in 1 to $width return ' ', '')), 1, $width)        
};

declare function m:_foldText($text as xs:string?, $width as xs:integer, $initialCol as xs:integer, $indent as xs:integer)
        as xs:string? {
    if (not($text)) then () else
    
    let $sep := concat('&#xA;', string-join(for $i in 1 to $indent return ' ', ''))
    let $len1 := $width - $initialCol
    let $len := string-length($text)
    return
        if ($len le $len1) then $text else
        
    let $lineRaw := substring($text, 1, $len1)
    let $line := replace($lineRaw, '^(.*\s).*', '$1')
    
    let $next := concat(replace(substring($lineRaw, 1 + string-length($line)), '^\s+', ''), substring($text, 1 + string-length($lineRaw))) 
    return 
        string-join(($line, m:_foldText($next, $width, $initialCol, $indent)), $sep)
};        

declare function m:_editItem($item as xs:string?, $edits as xs:string*)
        as xs:string? {
    if (not($item)) then () else
    
    let $s := $item
    let $s := if ($edits = 'lc') then lower-case($s) else $s
    let $s := if ($edits = 'uc') then upper-case($s) else $s
    return
        $s    
};

declare function m:_escapeReplacementString($s as xs:string)
        as xs:string {
    replace(replace($s, '\\', '\\\\'), '\$', '\\$')            
};        

  (:~
 : Returns a control element with attributes capturing 
 : the values of request parameters. If no name filter
 : is specified, all parameters are used, otherwise
 : only those matching the name filter. The attribute
 : values are the parameter string values.
 :
 : Usage note. Control elements are useful if request
 : parameters are used at a high frequence (e.g. during
 : the item processing within a recursion), as the
 : access to control attributes is faster than 
 : reading request parameters. Note, however, that the
 : control only represents the parameter string values.
 :
 : @param request a request element
 : @param nameFilter an optional name filter, using name filter syntax
 : @param removePrefixes an optional list of prefises to be
 :    removed from the parameter names
 : @return the control element
 :)
declare function m:getControl($request as element(), 
                              $nameFilter as xs:string?, 
                              $removePrefixes as xs:string*)
        as element(control) {                              
    let $names := m:getParamNames($request, $nameFilter)
    let $useNames := m:removeStringPrefixes($names, $removePrefixes, '.')
    return
        <control>{
            for $name in $useNames
            return
                attribute {$name} {m:getParamStringValue($request, $name)}
        }</control>   
};

