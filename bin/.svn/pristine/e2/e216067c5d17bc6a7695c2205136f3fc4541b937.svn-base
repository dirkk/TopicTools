(:~
 : _request.mod.xq - functions for loading and reading request data
 :
 : @version 20140214-1 first version 
 : ===================================================================================
 :)

module namespace m="http://www.ttools.org/xquery-functions";

import module namespace i="http://www.ttools.org/xquery-functions" at
   "_request_parser.mod.xq",
   "_request_getters.mod.xq",   
   "_dcat.mod.xq",
   "_extensions.mod.xq",
   "_help.mod.xq",   
   "_stringTools.mod.xq",   
   "_constants.mod.xq";   

declare namespace z="http://www.ttools.org/structure";

(:~
 : Parses a request string into a data structure.
 : 
 : @param request the request string
  : @return an element representing the request
 :)
declare function m:loadRequest($request as xs:string, $serviceModel as element()?)
        as element() {
(:        
    if (replace($request, '\s', '') eq '?') then <_help/> else
:)    
    let $parsed := i:_parseRequest($request)
    let $namesNormalized := m:_normalizeNames($parsed, $serviceModel)
    let $errors := $namesNormalized/z:errors    
    return if ($errors) then m:_getErrorReport($errors, ()) else    
        
    let $opConfigPlus := m:_getOperationConfig($namesNormalized/local-name(.), $serviceModel)
    let $errors := $opConfigPlus/z:errors    
    return if ($errors) then m:_getErrorReport($errors, ()) else
        
    let $valuesItemized := m:_itemizeParamValues($namesNormalized, $opConfigPlus, $serviceModel)
    let $valuesParsed := m:_parseParamValues($valuesItemized, $opConfigPlus, $serviceModel)
    let $groupErrors := m:_checkParamGroups($valuesParsed, $opConfigPlus, $serviceModel)
    let $errorsAll :=
        let $collected := ($valuesParsed/z:errors/*, $groupErrors/*)
        return
            if (empty($collected)) then () else
                <z:errors>{$collected}</z:errors>
    return
        if ($errorsAll) then m:_getErrorReport($errorsAll, ()) else  
            $valuesParsed
};

(:~
 : Transforms the result of parsing the request string into name/value pairs, 
 : replacing the operation name and the parameter names by normalized names.
 : 
 : Error policy: in case of errors, error diagnostics are not delivered as top level 
 : elements, but as a `z:errors` child of the response root element. The results of
 : successful evaluations are thus preserved and delivered together with any 
 : error diagnostics, making them accessible to subsequent checks. The rationale
 : is to enable as comprehensive error reports as possible.
 : 
 : May produce the following errors:
 :    UNKNOWN_OPERATION_NAME
 :    AMBIGUOUS_OPERATION_NAME
 :    UNKNOWN_PARAMEER_NAME
 :    AMBIGUOUS_PARAMETER_NAME
 :
 : @param parsed an element representing the name/value pairs obtained by parsing the 
 :    request string
 : @param serviceModel a definition of all service operations
 : @return an element representing the parsed and name-normalized request string
 :)
declare function m:_normalizeNames($parsed as element(), $serviceModel as element()?)
        as element() {
    if (not($serviceModel)) then $parsed else
    
    (: operation name :)
    let $rawName := $parsed/@operation
    let $candidateNames := for $n in $serviceModel/operation/@name order by lower-case($n) return $n
    let $matchingNames := m:_matchingNames($rawName, $candidateNames)
    let $opName := 
        if (count($matchingNames) eq 1) then $matchingNames 
        else if (count($matchingNames) eq 0) then
            <z:error type="UNKNOWN_OPERATION_NAME" name="{$rawName}"
                validNames="{$candidateNames}"
                msg="{concat('Unknown operation name (', $rawName, 
                '); valid names: ', string-join($candidateNames, ' '))}"/>
        else
            <z:error type="AMBIGUOUS_OPERATION_NAME" name="{$rawName}"
                matchingNames="{string-join($matchingNames, ', ')}"
                msg="{concat('Ambiguous operation name (', $rawName,
                '); matching names: ', string-join($matchingNames, ', '))}"/>
    return
        if ($opName instance of element(z:error)) then 
            <__UNKNOWN__>{
                <z:errors>{$opName}</z:errors>
            }</__UNKNOWN__> else
    
    (: parameter names :)
    let $opConfig := $serviceModel/operation[@name eq $opName]                
    let $paramsAndErrors :=
        for $param in $parsed/param
        let $rawName := $param/@name
        let $candidateNames := for $n in $opConfig/param/@name order by lower-case($n) return $n
        let $matchingNames := m:_matchingNames($rawName, $candidateNames)
        return
            if (count($matchingNames) eq 1) then 
                <param name="{$matchingNames}" value="{$param/@value}"/>
            else if (count($matchingNames) eq 0) then
                <z:error type="UNKNOWN_PARAMETER_NAME" name="{$rawName}"
                    validNames="{$candidateNames}" msg="{concat('Unknown parameter name (', $rawName, '); ',
                    'valid names: ', string-join($candidateNames, ' '))}"/>
            else
                <z:error type="AMBIGUOUS_PARAMETER_NAME" name="{$rawName}"
                    matchingNames="{string-join($matchingNames, ', ')}"
                    msg="{concat('Ambiguous parameter name (', $rawName, 
                    '); matching names: ', string-join($matchingNames, ', '))}"/>            
    let $errors := $paramsAndErrors/self::z:error
    let $params := $paramsAndErrors except $errors    
    let $errorsAll := if (not($errors)) then () else <z:errors>{$errors}</z:errors>
            
    return
        element {$opName} {$parsed/@storeq, $params, $errorsAll}
};

(:~
 : Transforms the intermediate representation of the request string, replacing the
 : concatenated parameter values by itemized values.
 : 
 : Error policy: in case of errors, error diagnostics are not delivered as top level 
 : elements, but as a `z:errors` child of the response root element. The results of
 : successful evaluations are thus preserved and delivered together with any 
 : error diagnostics, making them accessible to subsequent checks. The rationale
 : is to enable as comprehensive error reports as possible.
 : 
 : @param parsed an element representing the parsed request string
 : @return intermediate representation of the request in which external parameter 
 :    values are itemized
 :)
declare function m:_itemizeParamValues($normalizedNames as element(), 
                                       $opConfigPlus as element(), 
                                       $serviceModel as element()?)
        as element() {
    if (not($serviceModel)) then $normalizedNames else
    
    let $setParamNames := $normalizedNames/param/@name
    let $defaultParameters := $opConfigPlus/param[@default][not(@name = $setParamNames)]
    let $defaultsAdded := 
        if (not($defaultParameters)) then $normalizedNames else
            element {node-name($normalizedNames)} {
                $normalizedNames/@*,
                $normalizedNames/*,
                for $dparam in $defaultParameters return
                    <param name="{$dparam/@name}" value="{$dparam/@default}"/>
            }
    let $params :=
        for $param in $defaultsAdded/param
        let $paramConfig := $opConfigPlus/param[@name eq $param/@name]
        let $maxOccurs as xs:integer := $paramConfig/@maxOccurs/xs:integer(.)
        let $multiple as xs:boolean := $maxOccurs lt 0 or $maxOccurs gt 1
        let $rawItem := $param/@value/string(.)
        let $sep := 
            if (not($multiple)) then ()
            (: there are types for which the item separator is defined to be a semicolon :)
            else if ($paramConfig/@itemType = ('docDFD')) then '\s*;\s*'
            else ($paramConfig/@sep, '\s')[1]
        let $sep := replace($sep, '\\s\+', '\\s')
        let $sep := replace($sep, '^WS$', '\\s')
        let $items :=
            if (not($multiple)) then 
                $param/@value/replace(., '\\\\', '\\')
            else if ($sep eq '\s') then 
                tokenize(normalize-space($param/@value/replace(., '\\\\', '\\')), '\s+')
            else 
                m:_itemizeValue($param/@value, $sep)
        let $sepAtt := 
            if ($multiple and count($items) gt 1 and $sep eq '\s') then attribute sep {'\s'}
            else ()
        return
            element {node-name($param)} {
                $param/@name,
                attribute paramText {$rawItem},
                $paramConfig/@itemType,
                $paramConfig/@cardinality[string(.)],
                $sepAtt,
                if (count($items) eq 1) then 
                    $rawItem
                else if ($sep eq '\s') then 
                    string-join($items, ' ')
                else
                    for $item in $items return <value>{$item}</value>
            }
    let $errors := $defaultsAdded/z:errors            
    return
        element {node-name($defaultsAdded)} {        
            $defaultsAdded/@*,
            $params,
            $errors
        }
};

(:~
 : Returns an augmented operation config. The operation is identified by the operation name. 
 : In the returned operation config ...
 : - each parameter group element is augmented by a @members attribute containing the sorted
 :   list of member parameter names
 : - each parameter element is augmented by four additional attributes:
 :    @itemType - the result of removing the cardinality postfix from the type specification
 :    @cardinality - the cardinality postfix of the type specification
 :    @minOccurs - minimum number of occurrences
 :    @maxOccurs - maximum number of occurrences
 :
 : Error policy: in case of errors, error diagnostics (error elements) are not delivered 
 : as top level elements, but as a z:errors child of the response root element. This way, the
 : results of successful parameter evaluations are preserved and delivered together
 : with any error diagnostics, making them accessible to subsequent checks. The rationale
 : is to enable as comprehensive error reports as possible.
 : 
 : @param operationName the operation name
 : @param serviceModel a definition of all service operations 
  : @return an element describing the operation
 :)
declare function m:_getOperationConfig($operationName as xs:string, $serviceModel as element())
        as element()? {
    let $raw := $serviceModel/*[@name eq $operationName]
    
    (: $pgroups - elements representing the parameter groups :)
    let $pgroups :=
        for $g in $raw/pgroup
        let $gname := $g/@name
        let $members := $raw/param[@pgroup eq $gname]
        let $memberNames :=
            string-join(
                for $member in $members order by $member/@name/lower-case(.) return $member/@name
            , ' ')
        return
            element {node-name($g)} {$g/@*, attribute members {$memberNames}}
    
    (: $params - elements representing the parameters :)
    let $paramsAndErrors :=
        for $p in $raw/param
        let $typeSpec := m:_parseTypeSpec($p/@type)
        return
            if ($typeSpec/self::z:error) then $typeSpec else
            <param>{
                $p/@*,
                attribute typeSpec {$typeSpec/@typeSpec},
                attribute cardinality {$typeSpec/@cardSpec},                
                attribute itemType {$typeSpec/@itemType},
                attribute minOccurs {$typeSpec/@minOccurs},
                attribute maxOccurs {$typeSpec/@maxOccurs}                
            }</param>
    let $errors := $paramsAndErrors/self::z:error
    let $params := $paramsAndErrors except $errors    
    let $allErrors := if (not($errors)) then () else <z:errors>{$errors}</z:errors>
    return
        element {node-name($raw)} {$raw/@*, $params, $pgroups, $allErrors}
};    

(:~
 : Parses and validates the parameter values and writes the final XML representation 
 : of the request.
 :
 : Error policy: in case of errors, error diagnostics are not delivered as top level 
 : elements, but as a `z:errors` child of the response root element. The results of
 : successful evaluations are thus preserved and delivered together with any 
 : error diagnostics, making them accessible to subsequent checks. The rationale
 : is to enable as comprehensive error reports as possible.
 : 
 : @param valuesDetermined an intermediate representation of the request containing the not yet parsed
 :    and not yet validated parameter values
 : @opConfig the operation config
 : @serviceModel the service config
 : @return an element representing the request in which each parameter is represented by the 
 :    result of parsing and validating the original value
 :)
declare function m:_parseParamValues($valuesItemized as element(), 
                                     $opConfigPlus as element(), 
                                     $serviceModel as element()?)
        as element()* {
    if (not($serviceModel)) then $valuesItemized else

    (: check for missing parameters :)
    let $missingParamErrors :=
        for $p in $opConfigPlus/param[@minOccurs/xs:integer(.) gt 0]
                                     [not(@name = $valuesItemized/param/@name)]                                    
        return
            <z:error type="MISSING_PARAMETER" paramName="{$p/@name}"
                msg="{concat('Missing parameter: ', $p/@name, 
                    '; cardinality=', $p/@minOccurs, '-', $p/@maxOccurs/replace(., '-1', 'INF'))}"/>
                    
    (: check for cardinality errors, parse and validate the parameter values :)                    
    let $paramsAndErrors :=   
        for $param in $valuesItemized/param
        let $name := $param/@name/string(.)
        let $paramText := $param/@paramText
        let $valueItems := m:_getUnparsedParamItems($param)        
        let $paramConfigPlus := $opConfigPlus/param[@name eq $name]

        let $minOccurs := $paramConfigPlus/@minOccurs/xs:integer(.)[. ge 0]
        let $maxOccurs := $paramConfigPlus/@maxOccurs/xs:integer(.)[. ge 0]        
        let $type := $paramConfigPlus/@type
        let $itemType := $paramConfigPlus/@itemType
        let $cardinalityError := 
            if (count($valueItems) lt $minOccurs or count($valueItems) gt $maxOccurs) then
                let $sep := ($paramConfigPlus/@sep, '\s')[1] return
                <z:error type="INVALID_PARAMETER_CARDINALITY" paramName="{$name}" paramType="{$type}" 
                    itemCount="{count($valueItems)}" itemSeperator="{$sep}"
                    msg="{concat('Invalid parameter cardinality; actOccurs=', count($valueItems), '; minOccurs=', $minOccurs,
                     '; maxOccurs=', $maxOccurs)}"/>
            else ()                

        return (
            $cardinalityError,
            m:_parseParamValue($name, $paramText, $valueItems, $itemType, $paramConfigPlus)
        )       
    let $errors := $paramsAndErrors/(self::z:error, self::z:errors)
    let $params := $paramsAndErrors except $errors
    
    let $errorsAll :=
        let $collected := (
            $missingParamErrors,
            for $err in ($errors, $valuesItemized/z:errors) 
            return if ($err/self::z:errors) then $err/* else $err
        )                
        return
            if (not($collected)) then () else <z:errors>{$collected}</z:errors>   
    return
        element {node-name($valuesItemized)} {
            $valuesItemized/@storeq,        
            $params,
            $errorsAll
        }
};

(:~
 : Parses a parameter value into a structure representation. The
 : representation is an element whose name is the parameter name and
 : whose text content or item children represent the parsed value items.
 :
 : Error policy: in case of errors, a `z:errors`element is returned,
 : rather than an element named after the parameter and containing
 : the value items.
 :
 : @param name name the parameter name
 : @param value the parameter value
 : @param itemType the parameter type
 : @param paramConfig the parameter configuration
 : @return a "param" element capturing the information content
 :    of the parameter value
 :)
declare function m:_parseParamValue($name as xs:string, 
                                    $paramText as xs:string,
                                    $value as xs:string+, 
                                    $itemType as xs:string, 
                                    $paramConfig as element()?)
        as element()* {
        
    let $edits := $paramConfig/@edit/(for $item in tokenize(normalize-space(.), '\s') return $item)
    let $postEdits := $paramConfig/@postEdit/(for $item in tokenize(normalize-space(.), '\s') return $item)        
    let $typedValue :=              
        for $item in $value 
        let $itemText := m:_prepareParamValueItemText($item, $edits)
        let $typedItem := m:_parseParamValueItem($item, $itemType, $name)
        let $validationErrors :=            
            if (not($paramConfig) or 
                $typedItem instance of element(z:error) or 
                $typedItem instance of element(z:errors)) then () 
            else if ($itemType = ('DocDFD')) then ()
            else m:_checkFacets($itemText, $typedItem, $paramConfig)
        return
            if ($validationErrors) then $validationErrors else $typedItem
    let $paramErrors := $typedValue[. instance of element(z:error) or . instance of element(z:errors)]                    
    let $paramValue := if ($paramErrors) then () else $typedValue
    
    let $isValueNodes as xs:boolean := some $v in $paramValue satisfies $v instance of node()
    let $isValueSingleton as xs:boolean := count($paramValue) le 1
    
    let $concatenate as xs:boolean :=
        not($paramErrors) and 
            not($isValueNodes) and 
            not($isValueSingleton) and 
            not(exists($value[matches(string(.), '\s')]))
    let $paramValueNodes as node()* :=
        if ($paramErrors) then () 
        else if ($isValueNodes) then
            if ($isValueSingleton) then $paramValue else 
                $paramValue/<value>{.}</value>
        else
            if (empty($paramValue)) then ()
            else if ($isValueSingleton) then text {$paramValue}           
            else if ($concatenate) then 
                text {string-join(for $i in $paramValue return string($i), ' ')}
            else                    
                for $item in $paramValue return <value>{$item}</value>

    let $errors := if (not($paramErrors)) then () else
        <z:errors>{
            for $err in $paramErrors return if ($err/self::z:errors) then $err/* else $err
        }</z:errors>
        
    return
        if ($errors) then $errors else
        element {$name} {
            (: attribute type {$type}, :)
            attribute itemType {$itemType},
            attribute paramText {$paramText},
            if (not($isValueNodes)) then () else attribute nodeItems {'true'},
            if ($concatenate and not($isValueSingleton)) then attribute sep {'\s'} else (),
            $paramValueNodes
        }
};

(:~
 : Parses a parameter value string into a sequence of items.
 : 
 : @param request the request string
 : @return an element representing the request
 :)
declare function m:_itemizeValue($value as xs:string, $sepChar as xs:string)
      as xs:string* {
    m:_itemizeValueRC($value, $sepChar)
};

(:~
 : Recursive helper function of `_itemizeValue`. Extracts the next
 : value item and recursively calls itself for processing the
 : remainder of the value string, if there is a remainder.
 :
 : @param value the value string
 : @return the value items
 :) 
declare function m:_itemizeValueRC($value as xs:string?, $sepChar as xs:string)
        as xs:string* {
    if (empty($value)) then () else
    let $item := 
        replace($value, concat('^(.*?[^\\](\\\\)*)?', $sepChar, '($|[^', $sepChar, '].*)'), '$1', 's')    
    let $next := if ($item eq $value) then () else
        replace(substring($value, string-length($item) + 2), '^\s+', '')
    return (
        replace(replace($item, '\\\\', '\\'), concat('\\', $sepChar), m:_escapeReplacementString($sepChar)),
        if (empty($next)) then () else m:_itemizeValueRC($next, $sepChar)
    )            
};        

(:~
 : Prepares the text of a single parameter item for parsing.
 :
 : @param item the parameter item text
 : @return the parameter item as a typed item
 :)
declare function m:_prepareParamValueItemText($item as xs:string, $edits as xs:string*)
        as xs:string {
    let $itemChopped := replace(replace($item, '^\s+|\s+$', ''), '\\s', ' ')
    let $itemText :=
        if (empty($edits)) then $itemChopped else m:_editItem($itemChopped, $edits)
    return
        $itemText
};

(:~
 : Parses the text of a single parameter item and returns a typed item.
 : Examples of result item types:
 : - xs:string
 : - xs:integer
 : - xs:date
 : - element(nameFilter)
 : - element(dcat)
 :
 : Error policy: in case of errors, a `z:error` element is returned,
 : rather than a data item.
 :
 : @param item the parameter item text
 : @return the parameter item as a typed item
 :)
declare function m:_parseParamValueItem($itemText as xs:string, $itemType as xs:string, $name as xs:string)
        as item()? {
    let $typedItem := m:_parseParamValueItem_builtin($itemText, $itemType, $name)
    return if (exists($typedItem)) then $typedItem else
    
    let $typedItem :=
        (: *** nameFilter, nameFilterMap, pathFilter 
               ------------------------------------- :)
        if ($itemType eq 'nameFilter') then            
            let $nameFilter := i:parseNameFilter($itemText) return
            if ($nameFilter and not($nameFilter/self::z:errors)) then $nameFilter else
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': not a valid nameFilter.')}"/>                       
        else if (matches($itemType, '^nameFilterMap(\(.*\))?$')) then            
            let $nameFilterMap := i:parseNameFilterMap($itemText, $itemType) return
            if ($nameFilterMap and not($nameFilterMap/self::z:errors)) then $nameFilterMap else
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': not a valid nameFilter map.')}"/>                       
        else if ($itemType eq 'pathFilter') then            
            let $pathFilter := i:parsePathFilter($itemText) return
            if ($pathFilter and not($pathFilter/self::z:errors)) then $pathFilter else
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': not a valid pathFilter.')}"/>
                     
        (: *** docURI, docDFD, docCAT 
               ---------------------- :)                     
        else if ($itemType eq 'docURI') then            
            if (doc-available($itemText)) then $itemText else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no XML document at this location (',
                     $itemText, ').')}"/>                       
        else if ($itemType eq 'docDFD') then
            let $dcat := i:parseDocDFD($itemText) return            
            if ($dcat and not($dcat/self::z:errors)) then $dcat else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>                       
        else if ($itemType eq 'docCAT') then
            if (doc-available($itemText)) then 
                let $root := doc($itemText)/*
                return
                    if (local-name($root) eq 'dcat' and namespace-uri($root) eq '') then $itemText else
                        <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                             itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': document at this location (', 
                             $itemText, ') is not a dcat document.')}"/>                    
            else              
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no dcat document at this location (', 
                     $itemText, ').')}"/>                      
        else if ($itemType eq 'dfd') then
            let $dcat := i:parseDocDFD($itemText) return            
            if ($dcat and not($dcat/self::z:errors)) then $dcat else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>        
                     
        (: *** txtURI, txtDFD, txtLinesURI, txtLinesDFD 
               ---------------------------------------- :)             
        else if ($itemType eq 'txtURI') then
            let $itext := replace($itemText, '\\', '/')
            let $fields := i:_getItemFields($itext)
            let $encoding := ($fields[2], 'ISO-8859-1')[1]
            let $uri := $fields[1]
            return        
                if (unparsed-text-available($uri, $encoding)) then $itext else               
                    <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no text resource at this location (',
                     $uri, ').')}"/>                       
        else if ($itemType eq 'txtDFD') then
            let $dcat := i:parseTxtDFD($itemText) return            
            if ($dcat and not($dcat/self::z:errors)) then $dcat else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>                       
        else if ($itemType eq 'txtLinesURI') then   
            let $itext := replace($itemText, '\\', '/')
            let $fields := m:_getItemFields($itext)
            let $encoding := ($fields[2], 'ISO-8859-1')[1]
            let $uri := $fields[1]
            return
                if (unparsed-text-available($uri, $encoding)) then $itext else               
                    <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                         itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no text resource at this location (',
                         $uri, ').')}"/>
        else if ($itemType eq 'txtLinesDFD') then
            let $dcat := i:parseTxtDFD($itemText) return            
            if ($dcat and not($dcat/self::z:errors)) then $dcat else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>
                     
        (: *** csvURI, csvDFD 
               -------------- :)                     
        else if ($itemType eq 'csvURI') then
            let $itext := replace($itemText, '\\', '/')
            let $fields := i:_getItemFields($itext)
            let $encoding := ($fields[2], 'ISO-8859-1')[1]
            let $sep := ($fields[3], ';')[1] 
            let $delim := ($fields[4], '"')[1]            
            let $uri := $fields[1]
            return        
                if (unparsed-text-available($uri, $encoding)) then $itext else               
                    <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no text resource at this location (',
                     $uri, ').')}"/>                       
                         
        else if ($itemType eq 'csvDFD') then
            let $dcat := i:parseCsvDFD($itemText) return
            
            if ($dcat and not($dcat/self::z:errors)) then $dcat
(:            
                    let $fields := i:_getItemFields($itemText)
                    return
                        (: augment dcat - transfer field values into attributes (e.g. @sep) :)
                        element {node-name($dcat)} {
                            $dcat/@*,
                            attribute sep {($fields[6], ';')[1]},
                            attribute delim {($fields[7], '"')[1]},                            
                            attribute from {($fields[8], '1')[1]},                            
                            attribute to {($fields[9], '1')[-1]},
                            $dcat/node()                            
                        }
:)                        
            else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="SYNTAX_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': no valid directory filter descriptor; ',
                     'msg=', string-join($dcat//@msg, '# '))}"/>                       
           
        (: *** directory 
               --------- :)           
        else if ($itemType eq 'directory') then  
            let $itext := replace($itemText, '\\', '/')
            let $value := resolve-uri($itext, static-base-uri())
            let $value := file:resolve-path($value)
            return $value
        else i:parseNonStandardItemType($name, $itemType, $itemText)
    return
        $typedItem
};

declare function m:_parseParamValueItem_builtin($itemText as xs:string, $itemType as xs:string, $name as xs:string)
        as item()? {
    let $typedItem := 
        if ($itemType eq 'xs:string') then $itemText
        else if ($itemType eq 'xs:decimal') then $itemText
        else if ($itemType eq 'xs:decimal') then
            if ($itemText castable as xs:decimal) then xs:NCName($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value ''',
                    $itemText, ''' not a valid decimal number.')}"/>                       
        else if ($itemType eq 'xs:float') then
            if ($itemText castable as xs:float) then xs:NCName($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value ''',
                    $itemText, ''' not a valid float number.')}"/>                       
        else if ($itemType eq 'xs:double') then
            if ($itemText castable as xs:double) then xs:NCName($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value ''',
                    $itemText, ''' not a valid double number.')}"/>                       
        else if ($itemType eq 'xs:NCName') then
            if ($itemText castable as xs:NCName) then xs:NCName($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value ''',
                    $itemText, ''' not a valid NCName value.')}"/>                       
        else if ($itemType eq 'xs:boolean') then
            if ($itemText castable as xs:boolean) then xs:boolean($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value ''',
                    $itemText, ''' not a boolean value.')}"/>                       
        else if ($itemType eq 'xs:int') then
            if ($itemText castable as xs:int) then xs:int($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not an xs:int number.')}"/>                       
        else if ($itemType eq 'xs:integer') then
            if ($itemText castable as xs:integer) then xs:integer($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not an integer number.')}"/>                       
        else if ($itemType eq 'xs:positiveInteger') then
             if ($itemText castable as xs:positiveInteger) then xs:positiveInteger($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not a positive integer number.')}"/>                       
        else if ($itemType eq 'xs:nonNegativeInteger') then
            if ($itemText castable as xs:nonNegativeInteger) then xs:nonNegativeInteger($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not a non-negative integer number.')}"/>                       
        else if ($itemType eq 'xs:negativeInteger') then
            if ($itemText castable as xs:negativeInteger) then xs:negativeInteger($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not a negative integer number.')}"/>                       
        else if ($itemType eq 'xs:nonPositiveInteger') then
            if ($itemText castable as xs:nonPositiveInteger) then xs:nonPositiveInteger($itemText) else               
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                     $itemText, ') not a non-positive integer number.')}"/>                       
        else if ($itemType eq 'xs:date') then
            if ($itemText castable as xs:date) then xs:date($itemText) else
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                    itemValue="{$itemText}" msg="{concat('Parameter ''', $name, ''': item value (',
                    $itemText, ') not a valid date.')}"/>    
        else ()                    
    return
        $typedItem
};

(:~
 : Edits a parameter value item.
 : Currently supported editing:
 : lc - to lowercase
 : uc - to uppercase
 :
 : @param item parameter value item
 : @param edits controls the editing
 : @return the edited value item
 :)
declare function m:_editItem($item as xs:string?, $edits as xs:string*)
        as xs:string? {
    if (not($item)) then () else
    
    let $s := $item
    let $s := if ($edits = 'lc') then lower-case($s) else $s
    let $s := if ($edits = 'uc') then upper-case($s) else $s
    return
        $s    
};

(:~
 : Validates a parameter value against parameter facets.
 :
 : Error policy: in case of errors, a `z:errors` element is returned,
 : rather than a data item. 
 :)
declare function m:_checkFacets($itemText as xs:string, $typedItem as item(), $paramConfig as element()?)
        as element()* {
    if (not($paramConfig)) then ()
    else if ($typedItem instance of element(z:error) or $typedItem instance of element(z:errors))  then () else
    
    let $itemType := $paramConfig/@itemType
    let $name := $paramConfig/@name
        
    let $errors :=            
        if ($itemType = ('DocDFD')) then ()
        else (            
            (: *** check @values :)
            if (not($paramConfig/@fct_values)) then () else
            let $expectedItems := tokenize($paramConfig/@fct_values, ',\s*')
            return
                if ($itemText = $expectedItems) then () else          
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="values" validItemValues="{$paramConfig/@fct_values}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $typedItem, ') not among the valid ',
                        'item values (', $paramConfig/@fct_values, ').')}"/>
            ,
            (: *** check @pattern :)
            if (not($paramConfig/@fct_pattern)) then () else
            let $patternSpec := $paramConfig/@fct_pattern
            let $pattern := concat('^', replace($patternSpec, '#.*', ''), '$')
            let $options := string(replace($patternSpec, '.*#', '')[not(. eq $patternSpec)])
            return
                if (matches($itemText, $pattern, $options)) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="pattern" pattern="{$patternSpec}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $itemText, ') does not match the ',
                        'pattern (', $patternSpec, ').')}"/>
            ,
            (: *** check @length :)
            if (not($paramConfig/@fct_length)) then () else
            let $length := $paramConfig/@fct_length/xs:integer(.)
            return
                if (string-length($itemText) eq $length) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="length" length="{$length}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $itemText, ') does not have the required ',
                        'string length (', $length, ').')}"/>
            ,
            (: *** check @minLength :)
            if (not($paramConfig/@fct_minLength)) then () else
            let $minLength := $paramConfig/@fct_minLength/xs:integer(.)
            return
                if (string-length($itemText) ge $minLength) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="minLength" minLength="{$minLength}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $itemText, ') does not have the required ',
                        'minimum string length (', $minLength, ').')}"/>
            ,
            (: *** check @maxLength :)
            if (not($paramConfig/@fct_maxLength)) then () else
            let $maxLength := $paramConfig/@fct_maxLength/xs:integer(.)
            return
                if (string-length($itemText) le $maxLength) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="maxLength" maxLength="{$maxLength}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $itemText, ') has a length (', 
                        string-length($itemText), ') exceeding the maximum valid string length (', $maxLength, ').')}"/>
            ,
            (: *** check @min :)
            if (not($paramConfig/@fct_min)) then () else
            let $min := 
                if ($itemType eq 'xs:date') then $paramConfig/@fct_min/xs:date(.)
                else if ($itemType eq 'xs:time') then $paramConfig/@fct_min/xs:time(.)                
                else if ($itemType eq 'xs:dateTime') then $paramConfig/@fct_min/xs:dateTime(.)
                else $paramConfig/@fct_min/number(.)               
            return
                if ($typedItem ge $min) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="min" min="{$min}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $typedItem, ') less than the required ',
                        'minimum value (', $min, ').')}"/>
            ,
            (: *** check @minEx :)
            if (not($paramConfig/@fct_minEx)) then () else
            let $minEx := 
                if ($itemType eq 'xs:date') then $paramConfig/@fct_minEx/xs:date(.)
                else if ($itemType eq 'xs:time') then $paramConfig/@fct_minEx/xs:time(.)                
                else if ($itemType eq 'xs:dateTime') then $paramConfig/@fct_minEx/xs:dateTime(.)
                else $paramConfig/@fct_minEx/number(.)               
            return
                if ($typedItem gt $minEx) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="minEx" minEx="{$minEx}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $typedItem, ') less or equal to the required ',
                        'exclusive minimum value (', $minEx, ').')}"/>
            ,
            (: *** check @max :)
            if (not($paramConfig/@fct_max)) then () else
            let $max :=
                if ($itemType eq 'xs:date') then $paramConfig/@fct_max/xs:date(.)
                else if ($itemType eq 'xs:time') then $paramConfig/@fct_max/xs:time(.)                
                else if ($itemType eq 'xs:dateTime') then $paramConfig/@fct_max/xs:dateTime(.)
                else $paramConfig/@fct_max/number(.)               
            return
                if ($typedItem le $max) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="max" max="{$max}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $typedItem, ') larger than the maximum valid ',
                        'value (', $max, ').')}"/>            
            ,
            
            (: *** check @maxEx :)
            if (not($paramConfig/@fct_maxEx)) then () else
            let $maxEx :=
                if ($itemType eq 'xs:date') then $paramConfig/@fct_maxEx/xs:date(.)
                else if ($itemType eq 'xs:time') then $paramConfig/@fct_maxEx/xs:time(.)                
                else if ($itemType eq 'xs:dateTime') then $paramConfig/@fct_maxEx/xs:dateTime(.)
                else $paramConfig/@fct_maxEx/number(.)               
            return
                if ($typedItem le $maxEx) then () else                   
                    <z:error type="INVALID_PARAMETER_FACET" paramName="{$name}" itemType="{$itemType}" 
                        itemValue="{$itemText}" facet="maxEx" maxEx="{$maxEx}"
                        msg="{concat('Parameter ''', $name, ''': item value (', $typedItem, ') larger or equal to the required ',
                        'exclusive maximum value (', $maxEx, ').')}"/>            
            ,
            (: *** check @fileExists :)
            if (not($paramConfig/@fct_fileExists)) then () 
            else if ($paramConfig/@fct_fileExists eq 'true' and not(file:exists($typedItem))) then              
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$typedItem}" facet="fileExists" facetValue="true" 
                     msg="{concat('Parameter ''', $name, ''': file ''', $typedItem, ''' not found.')}"/>
            else if ($paramConfig/@fileExists eq 'false' and file:exists($typedItem)) then              
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$typedItem}" facet="fileExists" facetValue="false" 
                     msg="{concat('Parameter ''', $name, ''': file ', $typedItem, ''' already exists.')}"/>
            else (),           

            (: *** check @fct_dirExists :)
            if (not($paramConfig/@fct_dirExists)) then () 
            else if ($paramConfig/@fct_dirExists eq 'true' and not(file:exists($typedItem))) then              
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$typedItem}" facet="dirExists" facetValue="true" 
                     msg="{concat('Parameter ''', $name, ''': directory ''', $typedItem, ''' not an existent directory.')}"/>
            else if ($paramConfig/@fct_dirExists eq 'false' and file:exists($typedItem)) then              
                <z:error type="INVALID_PARAMETER_TYPE" subType="TYPE_ERROR" paramName="{$name}" itemType="{$itemType}" 
                     itemValue="{$typedItem}" facet="dirExists" facetValue="false" 
                     msg="{concat('Parameter ''', $name, ''': directory ', $typedItem, ''' already exists.')}"/>
            else ()         
            )
    return
        if (empty($errors)) then () else
            <z:errors>{$errors}</z:errors>           
};

(:~
 : Checks any constraints referring to parameter groups.
 :
 : Checks: minimum and maximum number of group members
 : 
 : Returns a `z:errors` element in case of errors, the empty
 : sequence otherwise.
 :
 : @param parsed an element representing the parsed request string
 : @return intermediate representation of the request in which external parameter 
 :    values are itemized
 :)
declare function m:_checkParamGroups($request as element(), 
                                     $opConfigPlus as element(), 
                                     $serviceModel as element()?)
        as element(z:errors)? {
    let $errors :=
    
    for $g in $opConfigPlus/pgroup
    let $gname := $g/@name
    let $memberNames := $g/@members/tokenize(., '\s+')
    let $actMemberNames := $request/*[local-name() = $memberNames]
    let $actOccurs := count($actMemberNames)
    let $minOccurs := $g/@minOccurs/xs:integer(.)    
    let $maxOccurs := $g/@maxOccurs/xs:integer(.)    
    return
        (: exactly one param must be set :)
        if ($minOccurs eq $maxOccurs) then
            if ($actOccurs eq $minOccurs) then () else
                <z:error type="INVALID_PARAMETER_GROUP" subType="MIN_OCCURS" paramGroupName="{$gname}" 
                    minOccurs="{$minOccurs}" maxOccurs="{$maxOccurs}" actOccurs="{$actOccurs}">{                       
                        attribute msg 
                            {concat('Exactly ', $minOccurs, ' of these parameters must be set: ',
                             string-join($memberNames, ', '), '.')}
                }</z:error>            
        else (       
            if (not($g/@minOccurs)) then () else
                if ($actOccurs eq $minOccurs) then () else
                    <z:error type="INVALID_PARAMETER_GROUP" subType="MIN_OCCURS" paramGroupName="{$gname}" 
                        minOccurs="{$minOccurs}" actOccurs="{$actOccurs}">{                       
                            attribute msg 
                                {concat('At least ', $minOccurs, ' of these parameters must be set: ',
                                 string-join($memberNames, ', '), '.')}
                    }</z:error>,
            if (not($g/@maxOccurs)) then () else
                if ($actOccurs eq $maxOccurs) then () else
                        <z:error type="INVALID_PARAMETER_GROUP" subType="MAX_OCCURS" paramGroupName="{$gname}" 
                            maxOccurs="{$maxOccurs}" actMembers="{$actOccurs}">{                       
                                attribute msg 
                                    {concat('At most ', $maxOccurs, ' of these parameters must be set: ', 
                                     string-join($memberNames, ', '), '.')}
                        }</z:error>
        )        
        
    return
        if (empty($errors)) then () else
            <z:errors>{$errors}</z:errors>
};

(:~
 : Parses a type specification and returns the result as an element
 : with attributes containing various parts of the parsing result:
 :
 : @typeSpec - the original type spec string
 : @cardSpec - the cardinality constraint string (e.g. '?' or '{0,7}' 
 : @itemType - the item type name
 : @minOccurs - the minimum number of occurrences
 : @maxOccurs - the maximum number of occurrences
 :
 : In case of an error, a single `z:error` element is returned, rather
 : than a `type` element.
 :
 : Possible errors:
 : INVALID_CARDINALITY_CONSTRAINT - if the constraint is syntactically incorrect
 :
 : @param typeSpec the type specification (e.g. 'xs:string+)
 : @return an element with attributes delivering parsing results, or
 :    an <z:error> element in case of a syntax error
 :)
declare function m:_parseTypeSpec($typeSpec as xs:string)
        as element() {
    let $itemType := replace($typeSpec, '^(\i\c+).*', '$1', 's')
    let $cardSpec := normalize-space(substring-after($typeSpec, $itemType))

    let $minMax :=
        if (not($cardSpec)) then (1, 1)
        else if ($cardSpec eq '?') then (0, 1)
        else if ($cardSpec eq '*') then (0, -1)            
        else if ($cardSpec eq '+') then (1, -1)
        else
            let $range := replace($cardSpec, '^\{(\d+|\d+,|,\d+|\d+,\d+)\}$', '$1', 's')
            return
                if ($range eq $cardSpec) then (: syntax error :)
                    <z:error type="INVALID_CARDINALITY_CONSTRAINT" typeSpec="{$typeSpec}"
                         msg="{concat('Invalid cardinality constraint: ', $cardSpec, '; typeSpec=', $typeSpec)}"/>
                else
                    if (not(contains($range, ','))) then (xs:integer($range), xs:integer($range))
                    else
                        let $parts := tokenize($range, '\s*,\s*')
                        return
                            if (not($range[1])) then (-1, xs:integer($range[2]))
                            else if (not($range[2])) then (xs:integer($range[1]), '-1')
                            else (xs:integer($range[1]), xs:integer($range[2]))
    return
        if ($minMax instance of element(z:error)) then $minMax else
        
        <type typeSpec="{$typeSpec}" 
              cardSpec="{$cardSpec}" 
              itemType="{$itemType}" 
              minOccurs="{$minMax[1]}" 
              maxOccurs="{$minMax[2]}"/>
};

(:~
 : Returns for a given name the normalized name(s) which the given name matches. 
 : The matches are determined as follows: (a) if there are candidate names which
 : are equal to the given name, ignoring case - the first or these candidate names;
 : (b) otherwise - all candidate names which start with the given name, ignoring case.
 : 
 : @param rawName the name as specified in the original request data
 : @return the matching name(s)
 :)
declare function m:_matchingNames($rawName as xs:string, $candidateNames as xs:string*)
        as xs:string* {
    if (empty($candidateNames)) then () else
    
    let $exactMatch := $candidateNames[matches($rawName, concat('^', ., '$'), 'i')][1]
    return
        if (exists($exactMatch)) then $exactMatch
        else
            let $rawPattern := concat('^', $rawName)
            let $matches := $candidateNames[matches(., $rawPattern, 'i')]
            return
                $matches
};

(:~
 : Writes an error report. Note that the 'error' elements may be in the
 : general topicTools namespace, as well as in a tool specific namespace.
 : Therefore, the element test does not specify an element name.
 :)
declare function m:_getErrorReport($errors as element()*, $format as xs:string?)
        as element(z:errorReport) {
    let $errors := for $err in $errors return if ($err/self::z:errors) then $err/* else $err        
    let $msgs := $errors/concat(m:_padRight(@type, 40), m:_foldText(@msg, 100, 40, 43))
    return
    <z:errorReport>{
        string-join((
            '', 
            'Invalid call',
            '============',
            '',
            $msgs, 
            '',
            '-------------------------------------',
            ''
        ), '&#xA;')  
    }</z:errorReport>
};        

declare function m:_padRight($s as xs:string?, $width as xs:integer)
        as xs:string? {
    substring(concat($s, string-join(for $i in 1 to $width return ' ', '')), 1, $width)        
};

declare function m:_foldText($text as xs:string?, $width as xs:integer, $initialCol as xs:integer, $indent as xs:integer)
        as xs:string? {
    if (not($text)) then () else
    
    let $sep := concat('&#xA;', string-join(for $i in 1 to $indent return ' ', ''))
    let $len1 := $width - $initialCol
    let $len := string-length($text)
    return
        if ($len le $len1) then $text else
        
    let $lineRaw := substring($text, 1, $len1)
    let $line := replace($lineRaw, '^(.*\s).*', '$1')
    
    let $next := concat(replace(substring($lineRaw, 1 + string-length($line)), '^\s+', ''), substring($text, 1 + string-length($lineRaw))) 
    return 
        string-join(($line, m:_foldText($next, $width, $initialCol, $indent)), $sep)
};        

declare function m:_escapeReplacementString($s as xs:string)
        as xs:string {
    replace(replace($s, '\\', '\\\\'), '\$', '\\$')            
};        

  (:~
 : Returns a control element with attributes capturing 
 : the values of request parameters. If no name filter
 : is specified, all parameters are used, otherwise
 : only those matching the name filter. The attribute
 : values are the parameter string values.
 :
 : Usage note. Control elements are useful if request
 : parameters are used at a high frequence (e.g. during
 : the item processing within a recursion), as the
 : access to control attributes is faster than 
 : reading request parameters. Note, however, that the
 : control only represents the parameter string values.
 :
 : @param request a request element
 : @param nameFilter an optional name filter, using name filter syntax
 : @param removePrefixes an optional list of prefises to be
 :    removed from the parameter names
 : @return the control element
 :)
declare function m:getControl($request as element(), 
                              $nameFilter as xs:string?, 
                              $removePrefixes as xs:string*)
        as element(control) {                              
    let $names := m:getParamNames($request, $nameFilter)
    let $useNames := m:removeStringPrefixes($names, $removePrefixes, '.')
    return
        <control>{
            for $name in $useNames
            return
                attribute {$name} {m:getParamStringValue($request, $name)}
        }</control>   
};

